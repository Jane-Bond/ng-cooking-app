{"ast":null,"code":"import { ofType } from \"@ngrx/effects\";\nimport { take, map, switchMap } from \"rxjs/operators\";\nimport * as RecipeActions from \"../recipes/store/recipe.actions\";\nimport { of } from \"rxjs\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@ngrx/store\";\nimport * as i2 from \"@ngrx/effects\";\nexport class RecipesResolverService {\n  constructor(store, actions$) {\n    this.store = store;\n    this.actions$ = actions$;\n  }\n  resolve(route, state) {\n    return this.store.select(\"recipes\").pipe(take(1), map(recipesState => {\n      return recipesState.recipes;\n    }), switchMap(recipes => {\n      if (recipes.length === 0) {\n        this.store.dispatch(new RecipeActions.FetchRecipes());\n        return this.actions$.pipe(ofType(RecipeActions.SET_RECIPES), take(1));\n      } else {\n        return of(recipes);\n      }\n    }));\n  }\n}\nRecipesResolverService.ɵfac = function RecipesResolverService_Factory(t) {\n  return new (t || RecipesResolverService)(i0.ɵɵinject(i1.Store), i0.ɵɵinject(i2.Actions));\n};\nRecipesResolverService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: RecipesResolverService,\n  factory: RecipesResolverService.ɵfac,\n  providedIn: \"root\"\n});","map":{"version":3,"mappings":"AAOA,SAAkBA,MAAM,QAAQ,eAAe;AAC/C,SAASC,IAAI,EAAEC,GAAG,EAAEC,SAAS,QAAQ,gBAAgB;AAIrD,OAAO,KAAKC,aAAa,MAAM,iCAAiC;AAChE,SAASC,EAAE,QAAQ,MAAM;;;;AAGzB,OAAM,MAAOC,sBAAsB;EACjCC,YACUC,KAA8B,EAC9BC,QAAiB;IADjB,UAAK,GAALD,KAAK;IACL,aAAQ,GAARC,QAAQ;EACf;EAEHC,OAAO,CAACC,KAA6B,EAAEC,KAA0B;IAC/D,OAAO,IAAI,CAACJ,KAAK,CAACK,MAAM,CAAC,SAAS,CAAC,CAACC,IAAI,CACtCb,IAAI,CAAC,CAAC,CAAC,EACPC,GAAG,CAAEa,YAAY,IAAI;MACnB,OAAOA,YAAY,CAACC,OAAO;IAC7B,CAAC,CAAC,EACFb,SAAS,CAAEa,OAAO,IAAI;MACpB,IAAIA,OAAO,CAACC,MAAM,KAAK,CAAC,EAAE;QACxB,IAAI,CAACT,KAAK,CAACU,QAAQ,CAAC,IAAId,aAAa,CAACe,YAAY,EAAE,CAAC;QACrD,OAAO,IAAI,CAACV,QAAQ,CAACK,IAAI,CAACd,MAAM,CAACI,aAAa,CAACgB,WAAW,CAAC,EAAEnB,IAAI,CAAC,CAAC,CAAC,CAAC;OACtE,MAAM;QACL,OAAOI,EAAE,CAACW,OAAO,CAAC;;IAEtB,CAAC,CAAC,CACH;EACH;;AArBWV,sBAAsB;mBAAtBA,sBAAsB;AAAA;AAAtBA,sBAAsB;SAAtBA,sBAAsB;EAAAe,SAAtBf,sBAAsB;EAAAgB,YADT;AAAM","names":["ofType","take","map","switchMap","RecipeActions","of","RecipesResolverService","constructor","store","actions$","resolve","route","state","select","pipe","recipesState","recipes","length","dispatch","FetchRecipes","SET_RECIPES","factory","providedIn"],"sourceRoot":"","sources":["/Users/evgeniabondar/Desktop/Git folder/ng-cooking-app/src/app/recipes/recipes-resolver.service.ts"],"sourcesContent":["import { Injectable } from \"@angular/core\";\nimport {\n  ActivatedRouteSnapshot,\n  Resolve,\n  RouterStateSnapshot,\n} from \"@angular/router\";\nimport { Store } from \"@ngrx/store\";\nimport { Actions, ofType } from \"@ngrx/effects\";\nimport { take, map, switchMap } from \"rxjs/operators\";\n\nimport { Recipe } from \"./recipe.model\";\nimport * as fromApp from \"../store/app.reducer\";\nimport * as RecipeActions from \"../recipes/store/recipe.actions\";\nimport { of } from \"rxjs\";\n\n@Injectable({ providedIn: \"root\" })\nexport class RecipesResolverService implements Resolve<Recipe[]> {\n  constructor(\n    private store: Store<fromApp.AppState>,\n    private actions$: Actions\n  ) {}\n\n  resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {\n    return this.store.select(\"recipes\").pipe(\n      take(1),\n      map((recipesState) => {\n        return recipesState.recipes;\n      }),\n      switchMap((recipes) => {\n        if (recipes.length === 0) {\n          this.store.dispatch(new RecipeActions.FetchRecipes());\n          return this.actions$.pipe(ofType(RecipeActions.SET_RECIPES), take(1));\n        } else {\n          return of(recipes);\n        }\n      })\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}