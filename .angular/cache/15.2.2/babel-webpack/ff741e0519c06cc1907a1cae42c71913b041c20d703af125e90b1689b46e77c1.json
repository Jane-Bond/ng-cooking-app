{"ast":null,"code":"import { ofType } from \"@ngrx/effects\";\nimport { catchError, switchMap, map, tap } from \"rxjs/operators\";\nimport * as AuthActions from \"./auth.actions\";\nimport { environment } from \"src/environments/environment\";\nimport { createEffect } from \"@ngrx/effects\";\nimport { of } from \"rxjs\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@ngrx/effects\";\nimport * as i2 from \"@angular/common/http\";\nimport * as i3 from \"@angular/router\";\nconst handleAuthentication = (expiresIn, email, userId, token) => {\n  const expirationDate = new Date(new Date().getTime() + expiresIn * 1000);\n  return new AuthActions.AuthenticateSuccess({\n    email: email,\n    userId: userId,\n    token: token,\n    expirationDate: expirationDate\n  });\n};\nconst handleError = () => {};\nexport class AuthEffects {\n  constructor(actions$, http, router) {\n    this.actions$ = actions$;\n    this.http = http;\n    this.router = router;\n    this.authSignup = createEffect(() => this.actions$.pipe(ofType(AuthActions.SIGNUP_START), switchMap(signupAction => {\n      return this.http.post(\"https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=\" + environment.firebaseAPIKey, {\n        email: signupAction.payload.email,\n        password: signupAction.payload.password,\n        returnSecureToken: true\n      }).pipe(map(resData => {\n        handleAuthentication(resData.expiresIn);\n      }), catchError(errorRes => {\n        //...return non-error Observable so our stream doesn't die\n        let errorMessage = \"An unknown error occured!\";\n        if (!errorRes.error || !errorRes.error.error) {\n          return of(new AuthActions.AuthenticateFail(errorMessage));\n        }\n        switch (errorRes.error.error.message) {\n          case \"EMAIL_EXISTS\":\n            errorMessage = \"This email already exists\";\n            break;\n          case \"EMAIL_NOT_FOUND\":\n            errorMessage = \"This email is not found\";\n            break;\n          case \"INVALID_PASSWORD\":\n            errorMessage = \"Wrong password\";\n        }\n        return of(new AuthActions.AuthenticateFail(errorMessage));\n      }));\n    })));\n    this.authLogin = createEffect(() => this.actions$.pipe(ofType(AuthActions.LOGIN_START), switchMap(authData => {\n      return this.http.post(\"https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=\" + environment.firebaseAPIKey, {\n        email: authData.payload.email,\n        password: authData.payload.password,\n        returnSecureToken: true\n      }).pipe(map(resData => {\n        const expirationDate = new Date(new Date().getTime() + +resData.expiresIn * 1000);\n        return new AuthActions.AuthenticateSuccess({\n          email: resData.email,\n          userId: resData.localId,\n          token: resData.idToken,\n          expirationDate: expirationDate\n        });\n      }), catchError(errorRes => {\n        //...return non-error Observable so our stream doesn't die\n        let errorMessage = \"An unknown error occured!\";\n        if (!errorRes.error || !errorRes.error.error) {\n          return of(new AuthActions.AuthenticateFail(errorMessage));\n        }\n        switch (errorRes.error.error.message) {\n          case \"EMAIL_EXISTS\":\n            errorMessage = \"This email already exists\";\n            break;\n          case \"EMAIL_NOT_FOUND\":\n            errorMessage = \"This email is not found\";\n            break;\n          case \"INVALID_PASSWORD\":\n            errorMessage = \"Wrong password\";\n        }\n        return of(new AuthActions.AuthenticateFail(errorMessage));\n      }));\n    })));\n    this.authSuccess = createEffect(() => this.actions$.pipe(ofType(AuthActions.AUTHENTICATE_SUCCESS), tap(() => {\n      this.router.navigate([\"/\"]);\n    })), {\n      dispatch: false\n    });\n  }\n}\nAuthEffects.ɵfac = function AuthEffects_Factory(t) {\n  return new (t || AuthEffects)(i0.ɵɵinject(i1.Actions), i0.ɵɵinject(i2.HttpClient), i0.ɵɵinject(i3.Router));\n};\nAuthEffects.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: AuthEffects,\n  factory: AuthEffects.ɵfac\n});","map":{"version":3,"mappings":"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","names":["ofType","catchError","switchMap","map","tap","AuthActions","environment","createEffect","of","handleAuthentication","expiresIn","email","userId","token","expirationDate","Date","getTime","AuthenticateSuccess","handleError","AuthEffects","constructor","actions$","http","router","pipe","SIGNUP_START","signupAction","post","firebaseAPIKey","payload","password","returnSecureToken","resData","errorRes","errorMessage","error","AuthenticateFail","message","LOGIN_START","authData","localId","idToken","AUTHENTICATE_SUCCESS","navigate","dispatch","factory"],"sourceRoot":"","sources":["/Users/evgeniabondar/Desktop/Git folder/ng-cooking-app/src/app/auth/store/auth.effects.ts"],"sourcesContent":["import { HttpClient } from \"@angular/common/http\";\nimport { Actions, ofType } from \"@ngrx/effects\";\nimport { catchError, switchMap, map, tap } from \"rxjs/operators\";\nimport * as AuthActions from \"./auth.actions\";\nimport { environment } from \"src/environments/environment\";\nimport { createEffect } from \"@ngrx/effects\";\nimport { of } from \"rxjs\";\nimport { Injectable } from \"@angular/core\";\nimport { Router } from \"@angular/router\";\n\nexport interface AuthResponseData {\n  kind: string;\n  idToken: string;\n  email: string;\n  refreshToken: string;\n  expiresIn: string;\n  localId: string;\n  registered?: boolean;\n}\n\nconst handleAuthentication = (\n  expiresIn: number,\n  email: string,\n  userId: string,\n  token: string\n) => {\n  const expirationDate = new Date(new Date().getTime() + expiresIn * 1000);\n  return new AuthActions.AuthenticateSuccess({\n    email: email,\n    userId: userId,\n    token: token,\n    expirationDate: expirationDate,\n  });\n};\n\nconst handleError = () => {};\n\n@Injectable()\nexport class AuthEffects {\n  authSignup = createEffect(() =>\n    this.actions$.pipe(\n      ofType(AuthActions.SIGNUP_START),\n      switchMap((signupAction: AuthActions.SignupStart) => {\n        return this.http\n          .post<AuthResponseData>(\n            \"https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=\" +\n              environment.firebaseAPIKey,\n            {\n              email: signupAction.payload.email,\n              password: signupAction.payload.password,\n              returnSecureToken: true,\n            }\n          )\n          .pipe(\n            map((resData) => {\n              handleAuthentication(resData.expiresIn);\n            }),\n            catchError((errorRes) => {\n              //...return non-error Observable so our stream doesn't die\n              let errorMessage = \"An unknown error occured!\";\n              if (!errorRes.error || !errorRes.error.error) {\n                return of(new AuthActions.AuthenticateFail(errorMessage));\n              }\n              switch (errorRes.error.error.message) {\n                case \"EMAIL_EXISTS\":\n                  errorMessage = \"This email already exists\";\n                  break;\n                case \"EMAIL_NOT_FOUND\":\n                  errorMessage = \"This email is not found\";\n                  break;\n                case \"INVALID_PASSWORD\":\n                  errorMessage = \"Wrong password\";\n              }\n              return of(new AuthActions.AuthenticateFail(errorMessage));\n            })\n          );\n      })\n    )\n  );\n\n  authLogin = createEffect(() =>\n    this.actions$.pipe(\n      ofType(AuthActions.LOGIN_START),\n      switchMap((authData: AuthActions.LoginStart) => {\n        return this.http\n          .post<AuthResponseData>(\n            \"https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=\" +\n              environment.firebaseAPIKey,\n            {\n              email: authData.payload.email,\n              password: authData.payload.password,\n              returnSecureToken: true,\n            }\n          )\n          .pipe(\n            map((resData) => {\n              const expirationDate = new Date(\n                new Date().getTime() + +resData.expiresIn * 1000\n              );\n              return new AuthActions.AuthenticateSuccess({\n                email: resData.email,\n                userId: resData.localId,\n                token: resData.idToken,\n                expirationDate: expirationDate,\n              });\n            }),\n            catchError((errorRes) => {\n              //...return non-error Observable so our stream doesn't die\n              let errorMessage = \"An unknown error occured!\";\n              if (!errorRes.error || !errorRes.error.error) {\n                return of(new AuthActions.AuthenticateFail(errorMessage));\n              }\n              switch (errorRes.error.error.message) {\n                case \"EMAIL_EXISTS\":\n                  errorMessage = \"This email already exists\";\n                  break;\n                case \"EMAIL_NOT_FOUND\":\n                  errorMessage = \"This email is not found\";\n                  break;\n                case \"INVALID_PASSWORD\":\n                  errorMessage = \"Wrong password\";\n              }\n              return of(new AuthActions.AuthenticateFail(errorMessage));\n            })\n          );\n      })\n    )\n  );\n\n  authSuccess = createEffect(\n    () =>\n      this.actions$.pipe(\n        ofType(AuthActions.AUTHENTICATE_SUCCESS),\n        tap(() => {\n          this.router.navigate([\"/\"]);\n        })\n      ),\n    { dispatch: false }\n  );\n\n  constructor(\n    private actions$: Actions,\n    private http: HttpClient,\n    private router: Router\n  ) {}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}