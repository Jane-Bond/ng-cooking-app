{"ast":null,"code":"import { ofType } from \"@ngrx/effects\";\nimport { catchError, switchMap, map, tap } from \"rxjs/operators\";\nimport * as AuthActions from \"./auth.actions\";\nimport { environment } from \"src/environments/environment\";\nimport { createEffect } from \"@ngrx/effects\";\nimport { of } from \"rxjs\";\nimport { User } from \"../user.model\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@ngrx/effects\";\nimport * as i2 from \"@angular/common/http\";\nimport * as i3 from \"@angular/router\";\nimport * as i4 from \"../auth.service\";\nconst handleAuthentication = (expiresIn, email, userId, token) => {\n  const expirationDate = new Date(new Date().getTime() + expiresIn * 1000);\n  const user = new User(email, userId, token, expirationDate);\n  localStorage.setItem(\"userData\", JSON.stringify(user));\n  return new AuthActions.AuthenticateSuccess({\n    email: email,\n    userId: userId,\n    token: token,\n    expirationDate: expirationDate,\n    redirect: true\n  });\n};\nconst handleError = errorRes => {\n  let errorMessage = \"An unknown error occured!\";\n  if (!errorRes.error || !errorRes.error.error) {\n    return of(new AuthActions.AuthenticateFail(errorMessage));\n  }\n  switch (errorRes.error.error.message) {\n    case \"EMAIL_EXISTS\":\n      errorMessage = \"This email already exists\";\n      break;\n    case \"EMAIL_NOT_FOUND\":\n      errorMessage = \"This email is not found\";\n      break;\n    case \"INVALID_PASSWORD\":\n      errorMessage = \"Wrong password\";\n  }\n  return of(new AuthActions.AuthenticateFail(errorMessage));\n};\nexport class AuthEffects {\n  constructor(actions$, http, router, authService) {\n    this.actions$ = actions$;\n    this.http = http;\n    this.router = router;\n    this.authService = authService;\n    this.authSignup = createEffect(() => this.actions$.pipe(ofType(AuthActions.SIGNUP_START), switchMap(signupAction => {\n      return this.http.post(\"https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=\" + environment.firebaseAPIKey, {\n        email: signupAction.payload.email,\n        password: signupAction.payload.password,\n        returnSecureToken: true\n      }).pipe(tap(resData => {\n        this.authService.setLogoutTimer(+resData.expiresIn * 1000);\n      }), map(resData => {\n        return handleAuthentication(+resData.expiresIn, resData.email, resData.localId, resData.idToken);\n      }), catchError(errorRes => {\n        //...return non-error Observable so our stream doesn't die\n        return handleError(errorRes);\n      }));\n    })), {\n      dispatch: false\n    });\n    this.authLogin = createEffect(() => this.actions$.pipe(ofType(AuthActions.LOGIN_START), switchMap(authData => {\n      return this.http.post(\"https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=\" + environment.firebaseAPIKey, {\n        email: authData.payload.email,\n        password: authData.payload.password,\n        returnSecureToken: true\n      }).pipe(tap(resData => {\n        this.authService.setLogoutTimer(+resData.expiresIn * 1000);\n      }), map(resData => {\n        return handleAuthentication(+resData.expiresIn, resData.email, resData.localId, resData.idToken);\n      }), catchError(errorRes => {\n        //...return non-error Observable so our stream doesn't die\n        return handleError(errorRes);\n      }));\n    })));\n    this.authRedirect = createEffect(() => this.actions$.pipe(ofType(AuthActions.AUTHENTICATE_SUCCESS), tap(authSuccessAction => {\n      if (authSuccessAction.payload.redirect) this.router.navigate([\"/\"]);\n    })), {\n      dispatch: false\n    });\n    this.autoLogin = createEffect(() => this.actions$.pipe(ofType(AuthActions.AUTO_LOGIN), map(() => {\n      const userData = JSON.parse(localStorage.getItem(\"userData\"));\n      if (!userData) {\n        return {\n          type: \"DUMMY\"\n        };\n      }\n      const loadedUser = new User(userData.email, userData.id, userData._token, new Date(userData._tokenExpirationDate));\n      if (loadedUser.token) {\n        const expirationDuration = new Date(userData._tokenExpirationDate).getTime() - new Date().getTime();\n        this.authService.setLogoutTimer(expirationDuration);\n        return new AuthActions.AuthenticateSuccess({\n          email: loadedUser.email,\n          userId: loadedUser.id,\n          token: loadedUser.token,\n          expirationDate: new Date(userData._tokenExpirationDate),\n          redirect: false\n        });\n      }\n      return {\n        type: \"DUMMY\"\n      };\n    })));\n    this.authLogout = createEffect(() => this.actions$.pipe(ofType(AuthActions.LOGOUT), tap(() => {\n      this.authService.clearLogoutTimer();\n      localStorage.removeItem(\"userData\");\n      this.router.navigate([\"/auth\"]);\n    })), {\n      dispatch: false\n    });\n  }\n}\nAuthEffects.ɵfac = function AuthEffects_Factory(t) {\n  return new (t || AuthEffects)(i0.ɵɵinject(i1.Actions), i0.ɵɵinject(i2.HttpClient), i0.ɵɵinject(i3.Router), i0.ɵɵinject(i4.AuthService));\n};\nAuthEffects.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: AuthEffects,\n  factory: AuthEffects.ɵfac\n});","map":{"version":3,"mappings":"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","names":["ofType","catchError","switchMap","map","tap","AuthActions","environment","createEffect","of","User","handleAuthentication","expiresIn","email","userId","token","expirationDate","Date","getTime","user","localStorage","setItem","JSON","stringify","AuthenticateSuccess","redirect","handleError","errorRes","errorMessage","error","AuthenticateFail","message","AuthEffects","constructor","actions$","http","router","authService","pipe","SIGNUP_START","signupAction","post","firebaseAPIKey","payload","password","returnSecureToken","resData","setLogoutTimer","localId","idToken","dispatch","LOGIN_START","authData","AUTHENTICATE_SUCCESS","authSuccessAction","navigate","AUTO_LOGIN","userData","parse","getItem","type","loadedUser","id","_token","_tokenExpirationDate","expirationDuration","LOGOUT","clearLogoutTimer","removeItem","factory"],"sourceRoot":"","sources":["/Users/evgeniabondar/Desktop/Git folder/ng-cooking-app/src/app/auth/store/auth.effects.ts"],"sourcesContent":["import { HttpClient } from \"@angular/common/http\";\nimport { Actions, ofType } from \"@ngrx/effects\";\nimport { catchError, switchMap, map, tap } from \"rxjs/operators\";\nimport * as AuthActions from \"./auth.actions\";\nimport { environment } from \"src/environments/environment\";\nimport { createEffect } from \"@ngrx/effects\";\nimport { of } from \"rxjs\";\nimport { Injectable } from \"@angular/core\";\nimport { Router } from \"@angular/router\";\nimport { User } from \"../user.model\";\nimport { AuthService } from \"../auth.service\";\n\nexport interface AuthResponseData {\n  kind: string;\n  idToken: string;\n  email: string;\n  refreshToken: string;\n  expiresIn: string;\n  localId: string;\n  registered?: boolean;\n}\n\nconst handleAuthentication = (\n  expiresIn: number,\n  email: string,\n  userId: string,\n  token: string\n) => {\n  const expirationDate = new Date(new Date().getTime() + expiresIn * 1000);\n  const user = new User(email, userId, token, expirationDate);\n  localStorage.setItem(\"userData\", JSON.stringify(user));\n\n  return new AuthActions.AuthenticateSuccess({\n    email: email,\n    userId: userId,\n    token: token,\n    expirationDate: expirationDate,\n    redirect: true,\n  });\n};\n\nconst handleError = (errorRes: any) => {\n  let errorMessage = \"An unknown error occured!\";\n  if (!errorRes.error || !errorRes.error.error) {\n    return of(new AuthActions.AuthenticateFail(errorMessage));\n  }\n  switch (errorRes.error.error.message) {\n    case \"EMAIL_EXISTS\":\n      errorMessage = \"This email already exists\";\n      break;\n    case \"EMAIL_NOT_FOUND\":\n      errorMessage = \"This email is not found\";\n      break;\n    case \"INVALID_PASSWORD\":\n      errorMessage = \"Wrong password\";\n  }\n  return of(new AuthActions.AuthenticateFail(errorMessage));\n};\n\n@Injectable()\nexport class AuthEffects {\n  authSignup = createEffect(\n    () =>\n      this.actions$.pipe(\n        ofType(AuthActions.SIGNUP_START),\n        switchMap((signupAction: AuthActions.SignupStart) => {\n          return this.http\n            .post<AuthResponseData>(\n              \"https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=\" +\n                environment.firebaseAPIKey,\n              {\n                email: signupAction.payload.email,\n                password: signupAction.payload.password,\n                returnSecureToken: true,\n              }\n            )\n            .pipe(\n              tap((resData) => {\n                this.authService.setLogoutTimer(+resData.expiresIn * 1000);\n              }),\n              map((resData) => {\n                return handleAuthentication(\n                  +resData.expiresIn,\n                  resData.email,\n                  resData.localId,\n                  resData.idToken\n                );\n              }),\n              catchError((errorRes) => {\n                //...return non-error Observable so our stream doesn't die\n                return handleError(errorRes);\n              })\n            );\n        })\n      ),\n    { dispatch: false }\n  );\n\n  authLogin = createEffect(() =>\n    this.actions$.pipe(\n      ofType(AuthActions.LOGIN_START),\n      switchMap((authData: AuthActions.LoginStart) => {\n        return this.http\n          .post<AuthResponseData>(\n            \"https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=\" +\n              environment.firebaseAPIKey,\n            {\n              email: authData.payload.email,\n              password: authData.payload.password,\n              returnSecureToken: true,\n            }\n          )\n          .pipe(\n            tap((resData) => {\n              this.authService.setLogoutTimer(+resData.expiresIn * 1000);\n            }),\n            map((resData) => {\n              return handleAuthentication(\n                +resData.expiresIn,\n                resData.email,\n                resData.localId,\n                resData.idToken\n              );\n            }),\n            catchError((errorRes) => {\n              //...return non-error Observable so our stream doesn't die\n              return handleError(errorRes);\n            })\n          );\n      })\n    )\n  );\n\n  authRedirect = createEffect(\n    () =>\n      this.actions$.pipe(\n        ofType(AuthActions.AUTHENTICATE_SUCCESS),\n        tap((authSuccessAction: AuthActions.AuthenticateSuccess) => {\n          if (authSuccessAction.payload.redirect) this.router.navigate([\"/\"]);\n        })\n      ),\n    { dispatch: false }\n  );\n\n  autoLogin = createEffect(() =>\n    this.actions$.pipe(\n      ofType(AuthActions.AUTO_LOGIN),\n      map(() => {\n        const userData: {\n          email: string;\n          id: string;\n          _token: string;\n          _tokenExpirationDate: string;\n        } = JSON.parse(localStorage.getItem(\"userData\"));\n        if (!userData) {\n          return { type: \"DUMMY\" };\n        }\n\n        const loadedUser = new User(\n          userData.email,\n          userData.id,\n          userData._token,\n          new Date(userData._tokenExpirationDate)\n        );\n\n        if (loadedUser.token) {\n          const expirationDuration =\n            new Date(userData._tokenExpirationDate).getTime() -\n            new Date().getTime();\n          this.authService.setLogoutTimer(expirationDuration);\n          return new AuthActions.AuthenticateSuccess({\n            email: loadedUser.email,\n            userId: loadedUser.id,\n            token: loadedUser.token,\n            expirationDate: new Date(userData._tokenExpirationDate),\n            redirect: false,\n          });\n        }\n        return { type: \"DUMMY\" };\n      })\n    )\n  );\n\n  authLogout = createEffect(\n    () =>\n      this.actions$.pipe(\n        ofType(AuthActions.LOGOUT),\n        tap(() => {\n          this.authService.clearLogoutTimer();\n          localStorage.removeItem(\"userData\");\n          this.router.navigate([\"/auth\"]);\n        })\n      ),\n    { dispatch: false }\n  );\n\n  constructor(\n    private actions$: Actions,\n    private http: HttpClient,\n    private router: Router,\n    private authService: AuthService\n  ) {}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}